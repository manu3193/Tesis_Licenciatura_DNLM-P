\chapter{Optimizaci\'on y paralelizaci\'on del filtro DNLM}
\label{ch:solucion}

En este cap\'itulo se presenta la paralelizaci\'on del filtro DNLM, con una comparaci\'on entre dos optimizaciones algor\'itmicas presentes en la literatura y sus respectivas versiones paralelas. La primera es una optimizaci\'on propuesta para el filtro DNLM, llamada DNLM-IIFFT. Se enfoca en disminuir la funci\'on de costo computacional mediante el uso de im\'agenes integrales y la transformada r\'apida de Fourier \cite{CalderonRamirez2017}. La segunda optimizaci\'on elegida es adaptada en este trabajo al filtro DNLM, debido a que fue presentada originalmente para el filtro NLM. Esta optimizaci\'on, en adelante DNLM-MA, acelera el c\'alculo de la funci\'on de pesado del filtro gracias al uso de un filtro de media m\'ovil, en adici\'on con el cambio en los ciclos de iteraci\'on y el aprovechamiento de la simetr\'ia de la funci\'on de pesado del filtro NLM \cite{Condat2010}. Ambas optimizaciones se detallan en la secci\'on\ref{ch:marco_opt}.

El paralelismo se emplea en dos formas: a nivel de tareas y a nivel de datos. En el caso del paralelismo a nivel de datos, este trabajo se enfoca en la vectorizaci\'on de la mayor cantidad de operaciones vectorizables presentes el algoritmo. Para esto se propone el uso de las primitivas de Intel para procesamiento de se\~nales e im\'agenes, llamadas \engl{Integrated Performance Primitives} (IPP). Las rutinas de esta biblioteca est\'an optimizadas para utilizar datos alineados en memoria y generar instrucciones SIMD vectorizadas. Estas instrucciones vectorizadas son aprovechadas por las unidades vectoriales presentes en la arquitectura Xeon Phi Knights Landing.



\section{Versiones del filtro DNLM a implementar}

Para lograr una correcta comparaci\'on entre las optimizaciones del filtro DNLM, se realiza la implementaci\'on de ambas optimizaciones DNLM-IIFT y DNLM-MA, sumadas a la versi\'on original del filtro DNLM con un s\'oli hilo que debe servir como punto base de comparaci\'on. Todas las versiones son desarrolladas usando la biblioteca IPP.

El funcionamiento del filtro DNLM se puede generalizar como un kernel $\psi_{\textrm{NLM}}$ que modifica a cada pixel de la imagen de entrada $U$, como se puede ver en (\ref{eq:weighted}) y (\ref{eq:nlmfunc}). El kernel $\psi_{\textrm{NLM}}$ determina el valor del pixel filtrado, iterando sobre los pixeles de la ventana de b\'usqueda $\Omega$ de $S$ pixeles. Una vez obtenido el peso del pixel, se multiplica por la imagen mejorada $U_{\textrm{USM}}$ producto del m\'etodo de \textit{Unsharp Mask}, como se aprecia en la figura \ref{fig:diagramabloqDNLM}.  Por \'ultimo, se normaliza el resultado para obtener la imagen final. 

\begin{figure}
\centering
\begin{tikzpicture}[node distance=2cm]
\node (start) [startstop] {Inicio};
\node (in1) [io, below of=start] {Entrada};
\node (pro1) [process, below of=in1] {Unsharp Mask};
\node (dec1) [process, right of=pro1, xshift=2cm] {Calcula Pesos};
\node (pro2b) [process, below of=pro1, yshift=-0.5cm] {Filtrado};
\node (out1) [io, below of=pro2b] {Salida};
\node (stop) [startstop, below of=out1] {Fin};

\draw [arrow] (start) -- (in1);
\draw [arrow] (in1) -- (pro1);
\draw [arrow] (in1) -| (dec1);
\draw [arrow] (dec1) |-  (pro2b);
\draw [arrow] (pro1) --  (pro2b);
\draw [arrow] (pro2b) -- (out1);
\draw [arrow] (out1) -- (stop);
\end{tikzpicture}
\caption[Diagrama funcional del filtro DNLM]{Diagrama funcional del filtro DNLM\label{fig:diagramabloqDNLM}}
\end{figure}

An\'alogamente, el diagrama funcional del filtro DNLM-IIFFT se muestra en la figura \ref{fig:diagramabloqDNLMiifft}. En este caso la diferencia principal radica en la utilizaci\'on de la imagen intregral y la convoluci\'on para el c\'alculo de los pesos y filtrado. 



\begin{figure}
\centering
\begin{tikzpicture}[node distance=2cm]
\node (start) [startstop] {Inicio};
\node (in1) [io, below of=start] {Entrada};
\node (dec1) [process, below of=in1, xshift=2cm] {Unsharp Mask};
\node (dec2) [process, below of=in1, xshift=-2cm] {Imagen Integral};
\node (pro2b) [process, below of=dec2, xshift=1cm, yshift=-0.5cm] {Filtrado};
\node (out1) [io, below of=pro2b] {Salida};
\node (stop) [startstop, below of=out1] {Fin};

\draw [arrow] (start) -- (in1);
\draw [arrow] (in1) -| (dec1);
\draw [arrow] (in1) -| (dec2);
\draw [arrow] (dec1) |-  (pro2b);
\draw [arrow] (dec2) -|  (pro2b);
\draw [arrow] (pro2b) -- (out1);
\draw [arrow] (out1) -- (stop);
\end{tikzpicture}
\caption[Diagrama funcional del filtro DNLM-IIFFT]{Diagrama funcional del filtro DNLM-IIFFT\label{fig:diagramabloqDNLMiifft}}
\end{figure}


\begin{figure}
\begin{algorithmic}[1]
\State $W\gets \Call{CreateMatrix}{U.size}$
\For{$i\gets 0, i < (U.rows - 1)$}
	\For{$j\gets 0, j < (U.cols - 1)$}
		\State $\Omega\gets \Call{GetPixelWindow}{i,j}$
        \State $E\gets \Call{CreateMatrix}{\Omega.size}$
        \State $\omega_{p}\gets \Call{GetPixelNeighborhood}{i,j}$
        \For{$n\gets 0, n < (\Omega.rows - 1)$}
        	\For{$m\gets 0, m < (\Omega.cols - 1)$}
        		\State $\omega_{m}\gets \Call{GetPixelNeighborhood}{n,m}$
                \State $E(n,m)\gets \Call{FrobeniusNorm}{\omega_m,\omega_p}$              
        	\EndFor 
        \EndFor 
        \State $W(i,j)\gets \Call{Average}{E}$
	\EndFor
\EndFor
\State \textbf{return} $W$
\end{algorithmic}
\caption{Pseudoc\'odigo del algoritmo del filtro DNLM\label{fig:euclid}}
\end{figure}

La regi\'on del algoritmo DNLM que se pretende paralizar est\'a dada entre la l\i'nea 7 y l\'inea 12 de la figura \ref{fig:euclid}, las cuales comprenden los ciclos aninados que sirven para recorrer cada uno de los pixeles de la imagen. Los hilos corren paralelamente hasta que llegan a la regi\'on cr\'itica mostrada en la l\'inea 13 de la figura \ref{fig:euclid}, donde deben escribir de manera s\'incrona. Esto permite a cada hilo procesar una cantidad de trabajo similar, distribuyendo la carga equitativamente.

De la misma menera, la figura \ref{fig:euclid2} muestra el pseudoc\'odigo de la optimizaci\'on DNLM-IIFT. En este caso la regi\'on que se pretende paralelizar comprende desde la l\'inea 3 a la l\'inea 15, en la que los hilos procesan de manera independiente los pixeles de la imagen hasta que ingresan a la regi\'on cr\'itica dada por la l\'inea 16, dond deben sincronizarse para escribir.

\begin{figure}

\begin{algorithmic}[1]
\State $W\gets \Call{CreateMatrix}{U.size}$
\State $I\gets \Call{IntegralImage}{U.*U}$
\For{$i\gets 0, i < (U.rows - 1)$}
	\For{$j\gets 0, j < (U.cols - 1)$}
		\State $\Omega\gets \Call{GetPixelWindow}{i,j}$
        \State $\omega_{p}\gets \Call{GetPixelNeighborhood}{i,j}$
        \State $W_{1}\gets \Call{CreateMatrix}{\Omega.size}$
        \State $s_{1} \gets I(i+\omega,j+\omega)-I(i-\omega-1,j-\omega-1)+I(i+\omega,j-\omega-1)+I(i-\omega-1,j+\omega)$
        \State $E\gets \Omega * \omega_{p}$ \Comment{Perform convolution}
        \For{$n\gets 0, n < (\Omega.rows - 1)$}
        	\For{$m\gets 0, m < (\Omega.cols - 1)$}
        		\State $s_{2} \gets I(n+\omega,m+\omega)-I(n-\omega-1,m-\omega-1)+I(n+\omega,m-\omega-1)+I(n-\omega-1,m+\omega)$
        		\State $W_{1}(n,m)\gets -2*E(n,m) + s_{1} + s_{2}$
        	\EndFor 
        \EndFor 
        \State $W(i,j)\gets \Call{Average}{W_{1}}$
	\EndFor
\EndFor
\State \textbf{return} $W$
\end{algorithmic}
\caption{Pseudoc\'odigo del algoritmo del filtro DNLM-IIFFT}\label{fig:euclid2}
\end{figure}

Se observa como disminuyen la cantidad de ciclos de iteraci\'on del algoritmo del filtro DNLM-IIFFT respecto a la versi\'on original para una imagen de entrada $U$ de $N$ pixeles, en su lugar se realiza una convoluci\'on entre la ventana de b\'usqueda $|\Omega|=S$ y el vecindario $|\omega|=P$. 

La optimizaci\'on DNLM-MA presenta una regi\'on paralelizable comprendida desde la l\'inea 2 hasta la l\'inea 12 de la figura \ref{fig:euclid3}, sin embargo, la variable $W$ es compartida por lo que las escrituras deben ser en una regi\'on cr\'itica para los hilos. 


\begin{figure}[H]

\begin{algorithmic}[1]
\State $W\gets \Call{CreateMatrix}{U.size}$
\For{$dn\gets 0, dn < (\Omega.size/2 - 1)$}
	\For{$dm\gets 0, dm < (\Omega.size/2 - 1)$}\Comment{Symmetry}
		\If	{$dn == 0 \And dm == 0$}
			\State $W\gets W + \Call{Ones}{W.size}$
		\Else
			\State $D\gets \Call{$D_{\Delta}$}{U,dn,dm}$  
			\State $E\gets D * \Call{Ones}{\omega.size}$ \Comment{Perform convolution}
			\State $W\gets W + \Call{Exp}{E/h}$ 
		\EndIf
	\EndFor
\EndFor
\State \textbf{return} $W$
\end{algorithmic}
\caption{Pseudoc\'odigo del algoritmo del filtro DNLM-MA}\label{fig:euclid3}
\end{figure}


 

